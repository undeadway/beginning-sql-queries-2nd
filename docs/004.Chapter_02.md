# 第二章　在一张表上的简单查询

如果一个数据库有着良好的设计，数据都应该保存在不同的表中。正如我们的高尔夫数据库就把会员、队伍、比赛分别保存在了不同的表中，并将它们的数据都关联在了一起。比如哪些会员加入了哪些队伍，参加过哪些比赛，以及其它。为了以最好的方式利用我们的数据，我们需要在不同的表中检查数据确认哪些是我们所要的。

在本章中，我们将会关注从单表中获取数据。这可能是数据库中的一张永久表（permanent table），也可能是用以临时储存复杂查询结果集的一部分的虚拟表（virtual table）。

我对“检索”和“返回”的讲述一直都不太准确。查询出结果对行来说发生了什么？事实上，我们并没有从表中删除数据或者将其放在哪里。查询就像是数据库对外的一个窗口，通过这个窗口可以看到我们想要的信息。如果数据库底层的数据有了改变，查询出的结果也会改变。只要你能理解这只是临时的，就并不难理解查询将“搜索”到的数据存放在“虚拟表”中。

## 行和列（字段）[^注0]的子集

在查询的时候选择行或者列的子集是一个非常惯用的手法。下文我们将关注从数据库的一张表中选择一些行和列[^注1]。通过其他方式从虚拟表中获得数据的方式也一样有效。

在决定要从表里面获取哪一行之前，必须要通过一个是否判断语句来表示检索条件。我们把条件作用在独立的表的每一行上，保留判断为真的条件并舍弃其它。所以当我们说要去找高尔夫俱乐部中的所有高级会员（senior member）时，我们仅仅需要的是 `Member` 表中 `MemberType` 字段的值是“Senior”的那些行的子集，就像 图2-1 所示。

> ![图2-1](./../img/Figure_2-1.png)  
> 图2-1 获取高级会员的行的子集

查找高级会员的 SQL 语句就像下面这样：

```
SELECT *
FROM Member
WHERE MemberType = 'Senior'
```

这条 SQL 有三个部分，或者说子句：`SELECT` 子句告诉了我们要找哪些字段。在这个例子中`*`的意思是查找所有的字段。`FROM` 子句告诉我们需要去查找那张（些）表，还有 `WHERE` 子句决定了只有符合特定条件的行会被选中到结果中。这里的条件是要检查 `MembetType` 域中的值。在 SQL 中，当我们给一个文本字段或者字符字段，我们需要给值的两边包裹上单引号，就像`'Senior'` 这样。

现在让我们看看数据库是怎么从表中找到那些我们想要的某些列的。通常我指的是选择出行的子集以及映射（project）出列的子集。映射一个列的子集通常是一系列操作的最后一步。我们可以这样认为：先把我们要的所有数据都收集起来，然后最后再去检出哪些我们想要的属性或者字段。我们将会在第七章中看到有些时候我们也会在引用某些集合操作前从原始（original）或者虚拟（ virtual ）表中中去映射相似的字段，比如 union 和 intersect 。

如果我们仅仅想要一个所有会员电话号码的列表，而不要其他诸如差点和加入日期的信息。图2-2 展示了 `Member` 表的 `mane` 和 `phone number` 字段的子集。

> ![图2-2](./../img/Figure_2-2.png)  
> 图2-2 映射必须要有电耗号码列的子集

从 `Member` 表中查找名字和电话号码的字段的 SQL 是这样的：

```
SELECT LastName, FirstName, Phone
FROM Member
```

因为我们要看到所有行的些字段的值，所以这次查询没有 `WHERE` 子句。

把行和列的检索结果组合成一个子集是一个非常简单的事情。如果我们仅仅想要得到高级会员的的电话列表，就像 图2-3 那样。

> ![图2-3](./../img/Figure_2-3.png)  
> 图2-3 查找出的高级会员的电话列表的行和列子集

图2-3中的 SQL 是这么写的：

```
SELECT LastName, FirstName, Phone
FROM Member
WHERE MemberType = 'Senior'
```

## 使用别名（alias）

当我们将不同的表组合在一起时候，我们的查询会变得越来越复杂。有些表或许会有一些同名的字段，这时候我们就需要去区分它们。在 SQL 中我们可以在查询中每个属性前面加上表名来表示这个字段来自哪张表。就像这样：

```
SELECT Member.LastName, Member.FirstName, Member.Phone
FROM Member
WHERE Member.MemberType = 'Senior'
```

因为输入完整的表名会比较麻烦，另外我们也在一些查询中去比较来自一张表的许多行的数据，所以 SQL 有了一个别名的概念。我们看一下下面这个查询：

```
SELECT m.LastName, m.FirstName, m.Phone
FROM Member m
WHERE m.MemberType = 'Senior'
```

在这里的 `FROM` 子句中，我们给 `Member` 表起了一个叫 `m` 的别名或者叫替代名。我们可以给别名起任何我们喜欢的名字，只要简单就好。然后在查询剩下的部分中我们可以使用这个别名去定位`Member` 里的任意属性。给每张表都起一个别名是一个好习惯。

## 保存查询

有些时候会需要将查询的结果放在一张新的永久表中（有些时候也叫它快照（snapshot）），因为一旦底层数据有所改变，这些快照就会过时，所以我们通常并不希望这么去做。我们最想要的是保存查询指令（query instructions），以便于我们可以在其他时候执行相同的命令。想一想我们的电话表查询，在俱乐部的会员列表更新后，我们都会重新生成电话表。而不是每次都要重新写查询，我们可以把储存起来的指令称为视图（view）。下面的代码展示了怎么去创建一个视图，我们可以通过这个视图来获得最新的电话表。我们必须要给这个视图起一个任意我们喜欢的名字（PhoneList 看起来不错），然后绑定 SQL 语句就可以得到我们想要的数据了。

```
CREATE VIEW PhoneList AS
SELECT m.LastName, m.FirstName, m.Phone
FROM Member m
```

你可以认为 `PhoneList` 是通过指令创建的一张“虚拟”表，所以我们在用其他真实的表进行查询的时候也用同样的方式来处理。我们只要知道虚拟表是在永久的 `Member` 表上执行查询语句动态创建的就可以了。这下我们就可以通过 `PhoneList` 视图非常简单地获得电话表了。

```
SELECT * FROM PhoneList
```

## 译注
[^注0]: 因为列和字段对应的单词都是 column ，所以今后如果不造成歧义，将不再刻意区分，看到哪个合适就用哪个

[^z注1]: 原书注：In the formal terms of relational algebra, retrieving a subset of rows (tuples) from a table (relation) is known as the select operation and retrieving a subset of attributes (columns) is known as the project operation. See Appendix 2 for more information.<br>中文翻译：关系代数的正规描述中，从一个表（关系）中获取行（元组（tuples））的子集叫做选择（select）操作，而获取属性（字段）的子集叫做映射（project）操作。详情见附录2