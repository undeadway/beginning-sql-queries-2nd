# 第二章　在一张表上的简单查询

如果一个数据库有着良好的设计，数据都应该保存在不同的表中。正如我们的高尔夫数据库就把会员、队伍、比赛分别保存在了不同的表中，并将它们的数据都关联在了一起。比如哪些会员加入了哪些队伍，参加过哪些比赛，以及其它。为了以最好的方式利用我们的数据，我们需要在不同的表中检查数据确认哪些是我们所要的。

在本章中，我们将会关注从单表中获取数据。这可能是数据库中的一张永久表（permanent table），也可能是用以临时储存复杂查询结果集的一部分的虚拟表（virtual table）。

我对“检索”和“返回”的讲述一直都不太准确。查询出结果对行来说发生了什么？事实上，我们并没有从表中删除数据或者将其放在哪里。查询就像是数据库对外的一个窗口，通过这个窗口可以看到我们想要的信息。如果数据库底层的数据有了改变，查询出的结果也会改变。只要你能理解这只是临时的，就并不难理解查询将“搜索”到的数据存放在“虚拟表”中。

## 行和列（字段）[^注0]的子集

在查询的时候选择行或者列的子集是一个非常惯用的手法。下文我们将关注从数据库的一张表中选择一些行和列[^注1]。通过其他方式从虚拟表中获得数据的方式也一样有效。

在决定要从表里面获取哪一行之前，必须要通过一个是否判断语句来表示检索条件。我们把条件作用在独立的表的每一行上，保留判断为真的条件并舍弃其它。所以当我们说要去找高尔夫俱乐部中的所有高级会员（senior member）时，我们仅仅需要的是 `Member` 表中 `MemberType` 字段的值是“Senior”的那些行的子集，就像 图2-1 所示。

> ![图2-1](./../img/Figure_2-1.png)  
> 图2-1 获取高级会员的行的子集

查找高级会员的 SQL 语句就像下面这样：

```
SELECT *
FROM Member
WHERE MemberType = 'Senior'
```

这条 SQL 有三个部分，或者说子句：`SELECT` 子句告诉了我们要找哪些字段。在这个例子中`*`的意思是查找所有的字段。`FROM` 子句告诉我们需要去查找那张（些）表，还有 `WHERE` 子句决定了只有符合特定条件的行会被选中到结果中。这里的条件是要检查 `MembetType` 域中的值。在 SQL 中，当我们给一个文本字段或者字符字段，我们需要给值的两边包裹上单引号，就像`'Senior'` 这样。

现在让我们看看数据库是怎么从表中找到那些我们想要的某些列的。通常我指的是选择出行的子集以及映射（project）出列的子集。映射一个列的子集通常是一系列操作的最后一步。我们可以这样认为：先把我们要的所有数据都收集起来，然后最后再去检出哪些我们想要的属性或者字段。我们将会在第七章中看到有些时候我们也会在引用某些集合操作前从原始（original）或者虚拟（ virtual ）表中中去映射相似的字段，比如 union 和 intersect 。

如果我们仅仅想要一个所有会员电话号码的列表，而不要其他诸如差点和加入日期的信息。图2-2 展示了 `Member` 表的 `mane` 和 `phone number` 字段的子集。

> ![图2-2](./../img/Figure_2-2.png)  
> 图2-2 映射必须要有电耗号码列的子集

从 `Member` 表中查找名字和电话号码的字段的 SQL 是这样的：

```
SELECT LastName, FirstName, Phone
FROM Member
```

因为我们要看到所有行的些字段的值，所以这次查询没有 `WHERE` 子句。

把行和列的检索结果组合成一个子集是一个非常简单的事情。如果我们仅仅想要得到高级会员的的电话列表，就像 图2-3 那样。

> ![图2-3](./../img/Figure_2-3.png)  
> 图2-3 查找出的高级会员的电话列表的行和列子集

图2-3中的 SQL 是这么写的：

```
SELECT LastName, FirstName, Phone
FROM Member
WHERE MemberType = 'Senior'
```

## 使用别名（alias）

当我们将不同的表组合在一起时候，我们的查询会变得越来越复杂。有些表或许会有一些同名的字段，这时候我们就需要去区分它们。在 SQL 中我们可以在查询中每个属性前面加上表名来表示这个字段来自哪张表。就像这样：

```
SELECT Member.LastName, Member.FirstName, Member.Phone
FROM Member
WHERE Member.MemberType = 'Senior'
```

因为输入完整的表名会比较麻烦，另外我们也在一些查询中去比较来自一张表的许多行的数据，所以 SQL 有了一个别名的概念。我们看一下下面这个查询：

```
SELECT m.LastName, m.FirstName, m.Phone
FROM Member m
WHERE m.MemberType = 'Senior'
```

在这里的 `FROM` 子句中，我们给 `Member` 表起了一个叫 `m` 的别名或者叫替代名。我们可以给别名起任何我们喜欢的名字，只要简单就好。然后在查询剩下的部分中我们可以使用这个别名去定位`Member` 里的任意属性。给每张表都起一个别名是一个好习惯。

## 保存查询

有些时候会需要将查询的结果放在一张新的永久表中（有些时候也叫它快照（snapshot）），因为一旦底层数据有所改变，这些快照就会过时，所以我们通常并不希望这么去做。我们最想要的是保存查询指令（query instructions），以便于我们可以在其他时候执行相同的命令。想一想我们的电话表查询，在俱乐部的会员列表更新后，我们都会重新生成电话表。而不是每次都要重新写查询，我们可以把储存起来的指令称为视图（view）。下面的代码展示了怎么去创建一个视图，我们可以通过这个视图来获得最新的电话表。我们必须要给这个视图起一个任意我们喜欢的名字（PhoneList 看起来不错），然后绑定 SQL 语句就可以得到我们想要的数据了。

```
CREATE VIEW PhoneList AS
SELECT m.LastName, m.FirstName, m.Phone
FROM Member m
```

你可以认为 `PhoneList` 是通过指令创建的一张“虚拟”表，所以我们在用其他真实的表进行查询的时候也用同样的方式来处理。我们只要知道虚拟表是在永久的 `Member` 表上执行查询语句动态创建的就可以了。这下我们就可以通过 `PhoneList` 视图非常简单地获得电话表了。

```
SELECT * FROM PhoneList
```

## 指定筛选行的条件

在前面章节的查询中我们可以看到，我们需要使用通过的条件或者标准来决定哪些行可以被筛选到查询的结果中。在下面的章节中，我们会看到更细致地研究通过不同方法来实现指定的复杂条件。

### 比较运算符（Comparison Operators）

提交是一个值为真或假的语句或者表达式，就像 `MemberType = 'Senior'` 。这种类型的表达式被称为布尔表达式，以研究了布尔表达式的19世纪英国数学家乔治·布尔命名。这些条件是我们用来从表中筛选数据的，常常需要去将一个属性的值和某些常量（constant）或者另一个属性去比较。比如我们可以要求属性的值是否相等、不等、或者大于其他值。表2-1 展示了一些我们会在查询中用到的比较运算符。

表2-1 比较运算符

| 运算符 | 释义 | 示例 |
| --- | --- | --- |
| = | Equals | 5=5 , 'Junior' = 'Junior' |
| < | Less than | 4<5 , 'Ann' < 'Zebedee' |
| <= | Less than or equal to | 4<=5 , 5<=5 |
| > | Greater than | 5>4 , 'Zebedee' > 'Ann' |
| >= | Greater than or equal to | 5>=4 , 5>=5 |
| <> | Not equal | 5<>4 , 'Junior' <> 'Senior' |

只是一个简短的提醒：**在 表2-1 的例子中我们示意了数字和一些字符（character）的比较**。我们重新去看第一章创建一张表，我们为每个字段都指定了一个类型，比如 `MemberID` 被指定为 `INT` (整数)，还有 `LastName` 是 `CHAR(20)` （20个字符的空间）。对于整数这样的字段，可以直接比较值。比较文本（text）或者字符字段，则通过字母顺序来比较，还有日期和时间字段则会按时间顺序（哪个时间更早）来比较。

当我们比较字符的时候基于 ASCII[^注2] 或者 Unicode[^注3] 来进行。




## 译注
[^注0]: 因为列和字段对应的单词都是 column ，所以今后如果不造成歧义，将不再刻意区分，看到哪个合适就用哪个

[^注1]: 原书注：In the formal terms of relational algebra, retrieving a subset of rows (tuples) from a table (relation) is known as the select operation and retrieving a subset of attributes (columns) is known as the project operation. See Appendix 2 for more information.<br>中文翻译：关系代数的正规描述中，从一个表（关系）中获取行（元组（tuples））的子集叫做选择（select）操作，而获取属性（字段）的子集叫做映射（project）操作。详情见附录2

[^注2] ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准 ISO/IEC646。ASCII 第一次以规范标准的类型发表是在 1967年 ，最后一次更新则是在 1986年 ，到目前为止共定义了 128 个字符。<br />参考网站：http://www.asciitable.com/
[^注3] Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年 开始研发，1994年 正式公布。