# 第三章　从连接（JOIN）开始

通过前面的章节，我们学习了怎么从单表中查找行或列的子集。第1章 中，我们学到了怎么把数据准确的存入数据库，信息的不同切片（aspect）都要存到对应的规范化的表中。很多查询都要从两张甚至更多的表去引用信息。我们可以用多种方式把两张表里的数据的属性组合成我们想要得到的样子。两张表间最常用的关联操作就是联合（JOIN）。在 第1章 中，我也介绍过两种不同的查询方法：**过程方法**和**结果方法**。第一种方法介绍了我们是怎么通过组合表来获得所需要的数据的，第二种方法则说明了被检索的数据要满足怎么样的条件。

## 连接的过程方法

连接可以让我们绑定有关系的两张表。让我们以 `Member` 表和 `Type` 为例，列出高尔夫俱乐部中每个成员的会费。通过连接筛选数据的第一步操作被称为**笛卡尔积（Cartesian Product）**。

### 笛卡尔积

笛卡尔积可以以任何意形式作用于任意两张表，因此成为了两表间最频繁的操作。也正如此，笛卡尔积可以提供的有效信息非常少，因此它最主要的作用就是连接的第一步。

笛卡尔积有点像是把两张表并排放在一起。让我们看看 图3-1 中所示的两张表：一张有所删节的 `Member` 表和一张 `Type` 表。

> ![图3-1](./../img/Figure_3-1.png)  
> 图3-1 数据库中的两张永久表

通过笛卡尔积得到的虚拟表会让其每一个字段都可以对应原始表中的字段。结果表中的每一行数据都来自原始表。图3-2 就展示了笛卡尔积中的前几行。

> ![图3-2](./../img/Figure_3-2.png)  
> `Member` 表和 `Type` 表的笛卡尔积的前几行

在上述的六个字段中，其中有四个字段来自 `Member` 表，另外两个字段来自 `Type` 表。每行来自 `Member` 表数据的一旁一定是来自 `Type` 表的数据。Melissa McKenzie 对应了四行数据—— `Member` 表中的数据匹配了 `Type` 表中的所有数据（Associate, Junior, Senior, Social）。而总的行数就变成了两张表的行数之积。换句话说，在上面裁剪后的 `Memner` 表我们要在 10 行数据之上再乘以 4 行（来自 `Type` 表），结果就变成了 40 行。笛卡尔就会返回一个非常非常大的结果集，这也是为什么它给不了多少有用信息的原因。

笛卡尔积在 `SQL` 中可以通过 `CORSS JOIN` 来实现。而如 图3-2 中所示的结果用到的 SQL 是：

```
SELECT * 
FROM Member m CROSS JOIN Type t; 
```

不是所有版本的 SQL 都支持相同的关键字和句式（phrase），比如 Access 2013 就不支持 `CORSS JOIN` 句式。在 1992 年，SQL 标准[^注1]加入了一些表示关系代数操作符号关键字如 CORSS JOIN，从那之后又有很多次的更新。但是，并不是所有的厂商都支持全部标准，以及一些其他厂商提供了更多的功能[^注2]。在这一章的后续中，我们会讨论当关系代数的关键字不可用时，通过结果方法所达到的同等的查询效果。

### 内连接（INNER JOIN）

## 连接的结果方法

## 扩展连接查询

### 一个过程方法


### 排序操作符


### 一个结果方法


### 通过图表接口表示连接

## 其他的连接类型

### 外连接

# 注
[^注1]: 原书注： International Organization for Standardization. Information technology — Database languages — SQL . ISO, Geneva, Switzerland, 1992. ISO/IEC 9075:1992

[^注2]: 这些多加的功能，也就是传说中的“方言”