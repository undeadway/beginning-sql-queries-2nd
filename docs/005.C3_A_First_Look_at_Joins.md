# 第三章　首先来看连接（JOIN）

通过前面的章节，我们学习了怎么从单表中查找行或列的子集。第1章 中，我们学到了怎么把数据准确的存入数据库，信息的不同切片（aspect）都要存到对应的规范化的表中。很多查询都要从两张甚至更多的表去引用信息。我们可以用多种方式把两张表里的数据的属性组合成我们想要得到的样子。两张表间最常用的关联操作就是联合（JOIN）。在 第1章 中，我也介绍过两种不同的查询方法：**过程方法**和**结果方法**。第一种方法介绍了我们是怎么通过组合表来获得所需要的数据的，第二种方法则说明了被检索的数据要满足怎么样的条件。

## 连接的过程方法

连接可以让我们绑定有关系的两张表。让我们以 `Member` 表和 `Type` 为例，列出高尔夫俱乐部中每个成员的会费。通过连接筛选数据的第一步操作被称为**笛卡尔积（Cartesian Product）**。

### 笛卡尔积

笛卡尔积可以以任何意形式作用于任意两张表，因此成为了两表间最频繁的操作。也正如此，笛卡尔积可以提供的有效信息非常少，因此它最主要的作用就是连接的第一步。

笛卡尔积有点像是把两张表并排放在一起。让我们看看 图3-1 中所示的两张表：一张有所删节的 `Member` 表和一张 `Type` 表。

> ![图3-1](./../img/Figure_3-1.png)  
> 图3-1 数据库中的两张永久表

通过笛卡尔积得到的虚拟表会让其每一个字段都可以对应原始表中的字段。结果表中的每一行数据都来自原始表。图3-2 就展示了笛卡尔积中的前几行。

> ![图3-2](./../img/Figure_3-2.png)  
> 图3-2 `Member` 表和 `Type` 表的笛卡尔积的前几行

在上述的六个字段中，其中有四个字段来自 `Member` 表，另外两个字段来自 `Type` 表。每行来自 `Member` 表数据的一旁一定是来自 `Type` 表的数据。Melissa McKenzie 对应了四行数据—— `Member` 表中的数据匹配了 `Type` 表中的所有数据（Associate, Junior, Senior, Social）。而总的行数就变成了两张表的行数之积。换句话说，在上面裁剪后的 `Member` 表我们要在 10 行数据之上再乘以 4 行（来自 `Type` 表），结果就变成了 40 行。笛卡尔就会返回一个非常非常大的结果集，这也是为什么它给不了多少有用信息的原因。

笛卡尔积在 SQL 中可以通过 `CORSS JOIN` 来实现。而如 图3-2 中所示的结果用到的 SQL 是：

```
SELECT * 
FROM Member m CROSS JOIN Type t; 
```

不是所有版本的 SQL 都支持相同的关键字和句式（phrase），比如 Access 2013 就不支持 `CORSS JOIN` 句式。在 1992 年，SQL 标准[^注0]加入了一些表示关系代数操作符号关键字如 CORSS JOIN，从那之后又有很多次的更新。但是，并不是所有的厂商都支持全部标准，以及一些其他厂商提供了更多的功能[^注1]。在这一章的后续中，我们会讨论当关系代数的关键字不可用时，通过结果方法所达到的同等的查询效果。

### 内连接（INNER JOIN）

如果关注 图3-2 中的表，你可以发现很多行兵没有太多的意义。比如第一、第三、第四行的数据，初级会员的 Melissa McKenzie 却显示其为临时会员、高级会员和特别会员。很难看出这些数据究竟会有什么用。[^注2]如果我们只把 `Member` 表中的 `MemberType` 字段和 `Type` 表中 `Type` 字段相匹配的行拿出来，我们就得到了我们想要的信息，比如每个会员的会费。图3-3 就展示了这点

> ![图3-3](./../img/Figure_3-3.png)  
> 图3-3 从笛卡尔积中筛选出子集

图3-3 的所示的操作（从笛卡尔积中筛选出一个子集）被称为**内连接**（简称连接）。所使用的行查询条件也被称为**连接条件**。图3-3 的 SQL 如下：

```
SELECT * 
FROM Member m INNER JOIN Type t ON m.MemberType = t.Type; 
```

在通过使用关键字 `INNER JOIN` 之后，我们可以看到为了筛选出所要的行而用了关键字 `ON` 。再说一次，某些版本的 SQL 并不支持 INNER JOIN 句式。所以，我们会在这一章的稍后中讲述其他的查询方法。

我们所要进行连接的两个字段（MemberType 和 Type）是必须**可以被连接**（join compatible）的。专业点说，就是它们必须来自相同的取值范围或者可能的值的集合。实际上，可以被连接通常也就表示那些字段在不同的表中都有着相同的数据类型。比如都是数字或者都是日期的字段。不同的数据库可能会对连接的兼容性有着不同的处理。有些数据库会允许一张表示浮点数而另一张表示整数的连接。有些数据库或许会要求文本字符的宽度都要一致（比如 `CHAR(10)` 或者 `CHAR(15)`），而其他的就不行。我建议不要去尝试着连接不同的类型，除非你非常清楚你在干什么。和之前一样，最好的方法就是在你设计表的时候就想清楚。把那些可能要做成连接的属性都设置为同一个类型。

## 连接的结果方法

让我们来看看用结果方法进行进行连接。先不去管怎么组织表，而是去看看要检索出目标行需要满足哪些条件。

让我们通过笛卡尔积来开始：我们需要一个由有效的表的有效的行组成的集合。图3-4 告诉了我们怎么去构想这种关系。我们看到这两张表，所以我们需要两个指示符来标记行。`指示符m` 在 `Member` 表中都有对应的值。当然，它现在在第 3 行。`Member` 表中的每一行，`指示符t` 都可以在 `Type` 表中找到对应的值。通过笛卡尔积我们可以知道所有的有效行。更明确地说，图3-4 的笛卡尔积云云说得更直点就是：

> 我会把所有来自 `Member` 表中的 m 行的所有属性 和所有来自 `Type` 表中的 t 行的所有属性都保留下来

> ![图3-4](./../img/Figure_3-4.png)  
> 图3-4 行内指示符 m 和 t 各自指向 `Member` 表和 `Type` 表中的每一行

如 图3-4 所说的查询 以及 图3-2 那样的输出结果的 SQL如下：

```
SELECT *
FROM Member m, Type t
```

上面的 SQL 会返回我们之前所描述过的 `CORSS JION` 的相同的结果。

在使用 `JOIN` 进行搜索的时候，需要指定对于特定的数据不管在哪张表中都相同的额外搜索条件。说得更直点就是：

> 我把所有来自 m行 的属性和来自 t行 的属性全部列出，只要 m 来自于 `Member` 表，t 来自于 `Type` 表，以及 `m.MemberType = t.Type`。

图3-5 描述了一对满足搜索关系的行。如果让 m 保持原位，而 t 下降一行，那么两者之间的条件关系就不再被满足，也就无法再获得合适的数据。

> ![图3-5](./../img/Figure_3-5.png)  
> 图3-5 当 `m.MemberType = t.Type` 时行就会被查找出来

我们可以把 图3-5 中描述的查询翻译成以下 SQL：

```
SELECT *
FROM Member m, Type t
WHERE m.MemberType = t.Type;
```

如果我们仔细看一下上面的 SQL ，可以看到在最开始的两行表达了笛卡尔积，还有 `WHERE` 子句在最后一行选择了两张表中会员类型一致的子集。这就是我们在之前的章节中讲过的`内连接`。下面用内连接写成的 SQL 会和前面的 SQL 会找到相同的行，再看一眼：

```
SELECT *
FROM Member m INNER JOIN Type t ON m.MemberType = t.Type;
```

第一种 SQL 表达了要查找哪些行（结果方法），之后的 SQL 表达了我们允许采用哪些操作去从行中查找数据（过程方法）。使用那种方法并不重要，重要的是要学会去思考怎么构筑查询。有些时候你选择的方式会影响到查询的性能，我们会在 第9章 中进行详细说明。事实上，大多数数据库要么会对 SQL 进行优化；要么直接找一个执行速度快的查询方式，而根本不管你怎么写。比如 SQL Server 对 JOIN 的两种表达都采用了同样的方式。SQL Server 2013 在实际操作中如果采用默认的界面写第一种 SQL 生成一个视图，程序会自动把代码转换成使用 `INNER JOIN` 的形式。

## 扩展连接查询

既然我们已经把连接加入了仓库，我们就可以执行多种类型的查询了。因为含有操作的查询的结果是在另一张表中，我们可以稍后连接那个结果去第三张表，或者其他表，最后选择想要行和列找到想要的结果。

让我们看一下 图3-6 中几张表的例子。`Entry` 表使用了两个外键（foreign key）`MemberID` 和 `TourID` 用来维持那些参加过不同比赛的会员的信息。`Entry` 表中的第一行数据记录了  118号会员 在 2014年 参加了 第24场 的比赛。如果我们想要更多的信息（比如会员姓名、比赛名称），我们需要利用外键在 `Member` 表和 `Tournament` 表从中找各自寻合适的行。

> ![图3-6](./../img/Figure_3-6.png)  
> 图3-6 俱乐部数据库中的永久表

让我们找到在 2014 年中所有名叫“Leeston”的比赛。我会描述两种不同的方法，以及你或许会找到一个或者更多的其他方法。

### 一个过程方法

我们从三张表开始，所以我们需要一些操作来组合这三张表中的数据相互融合。我们将 `Member` 表 连接到 `Entry` 表，然后把连接后的结果集和 `Tournament` 表再进行连接，如 图3-7 所示。

> ![图3-7](./../img/Figure_3-7.png)  
> 图3-7 联合 `Member`、`Entry` 、`Tournament` 三张表

第一次连接在 `Member` 表和 `Entry` 表之间通过 `m.MemberID = e.MemberID` 的条件来进行结合，就像 图3-7 中的矩形块框出数据的所示。第二次连接在第一次连接的结果集和 `Tournament` 表之间通过 `e.TourID = t.TourID` 的条件来结合，就像 图3-7 里的圆所圈出的数据所示。不管我们是先连接 `Entry` 表 和 `Tournament` 表，还是先联合 `Entry` 表 和 `Member` 表都没有太大的差别。

把两个连接写成 SQL ：

```
SELECT *
FROM (Member m INNER JOIN Entry e ON m.MemberID = e.MemberID)
        INNER JOIN Tournament t ON e.TourID = t.TourID;
```

通过连接查询得到的虚拟表的结果集包含了我们所想要的全部信息。我们仅需要将满足年和比赛名称的行通过 `WHERE` 子句筛选即可。然后就可以通过在 `SELECT` 子句中指定属性的名称来将他们映射到最终的结果中。完整的 SQL 查询返回了“参加过在 2014年 举办的名为‘Leeston’的比赛所有会员的姓名”：

```
SELECT LastName, FirstName
FROM (Member m INNER JOIN Entry e ON m.MemberID = e.MemberID)
        INNER JOIN Tournament t ON e.TourID = t.TourID
WHERE TourName = 'Leeston'
AND Year = 2014;
```

### 换种方法

在上面的章节中，我们首先把所有的表都进行了连接，然后再找到对应的行和列，连接的结果如 图3-7 所示的中间表。如果有非常多的会员和非常多的比赛，这个中间表将会非常非常之大。我们可以用不用的操作顺序来执行这些操作。我们可以先仅在 `Tournament` 表中搜索“Leeston”和在 `Entry` 表中搜索“2014”，就如 图3-8 的所示。把这两张较小的表进行连接后再和 `Member` 表进行连接，就会得到一张小的多的中间表。

> ![图3-8](./../img/Figure_3-8.png)  
> 图3-8 在联合前分别重 `Member`、`Entry` 、`Tournament` 中找出数据行

所以我们搞错了操作的顺序么？回答是：是——操作顺序不一会有巨大的差别——但当你用 SQL 时，不用去考虑这些问题。不管 SQL 怎么写都被同样的执行。所有 SQL 语句在执行前都会被你所使用的数据程序进行优化。这表示数据库程序会找到最合适的方法去执行。某些数据库程序做的非常好，有些却不怎么样。很多数据库程序有可以让你查阅的执行了怎么样的查询的统计工具。对很多查询来说，你写出的 SQL 并不会对实际运行产生多少差异，但你可以让查询的效率变得更高，比如给表加上索引g（index）。我们将会在第九章中详细的探讨这些问题。

### 一个结果方法

我们所便编写的 SQL 通常并不影响查询的效率是因为 SQL 都基于关系算法，描述了查询到的行多必须满足的条件[^注3]。最初的 SQL 标准中甚至没有像 `INNER JOIN` 这样的关键字。在 SQL 没有这些关键字就没法描述想要获得的数据该是怎么样的，因为它们没有办法描述它们是**怎么**工作的。让我们来看看怎么通过结果方法来找到谁在 2014 年参加了名为“Leeston”比赛的会员。

我们只想从 `Member` 表中得到一些名字。忘了连接，在你完全不知道外键、连接以及其他数据库等知的情况下，你会怎么从眼前这三张表中找到某个特定的名字。把手指指向某张表中的记录，就像下面的 图3-9 中所示的那样。

> ![图3-9](./../img/Figure_3-9.png)  
> 图3-9 通过行内指示符去描述满足搜索条件的行

当我们去找 Babara Olson 这个名字的时候，怎么知道 图3-9 中的哪个 `m` 才是我们想要的目标？我们是怎么知道的？首先，我们先在 `Entry` 表中找到她的 ID（235）所对应的在 2014 年的那行数据。然后我们
必须在 ` Tournament` 表中找到 Leestion 比赛所对应的行，并确认其 id 是 24 。再观察 图3-9 ，我们发现那些刚刚找到的行

> 

```
SELECT m.LastName, m.FirstName
FROM Member m, Entry e, Tournament t
WHERE m.MemberID = e.MemberID
        AND e.TourID = t.TourID
        AND t.TourName = 'Leeston' AND e.Year = 2014;
```

### 通过图表接口表示连接

## 其他的连接类型

### 外连接

# 注
[^注0]: 原书注： International Organization for Standardization. Information technology — Database languages — SQL . ISO, Geneva, Switzerland, 1992. ISO/IEC 9075:1992

[^注1]: 这些多加的功能，也就是传说中的“方言”

[^注2]: 这里的原文还有一句话，个人感觉逻辑有些跳，而且前半句和后面又些重复，所以姑且删除了这一句。<br />原文：However, the second row, where the member types from each table match, is useful because it allows us to see what fee Melissa pays. 

[^注3]: 这里的原话是个长难句，有些看不懂，特别是最后一个逗号后面的部分。姑且先这么翻译，给出原文供参考。<br />原文：The reason that the way we write our SQL statements often doesn’t affect the efficiency of a query is that SQL is fundamentally based on relational calculus, which describes the criteria the retrieved rows must meet.
